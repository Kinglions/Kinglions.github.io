<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="kinglionsfrank@163.com"><title>RunTime的了解与使用 · Frank(不羁放荡爱自由)</title><meta name="description" content="runtime这个词对于iOS程序猿童鞋来说，都是一个“耳熟能详”的名词，因为runtime就像面试中的“诅咒”一样，每当遇到相关面试题，都是几家欢喜几家愁。那么runtime到底是什么呢？runtime是 OC底层的一套C语言的API，编译器最终都会将OC代码转化为运行时代码。不过苹果已经将 Ob"><meta name="keywords" content="Hexo,HTML,Frank,CSS,iOS,苹果"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo.png" style="width:127px;"><h4 title=""><a href="/">Frank(不羁放荡爱自由)</a></h4><div class="description"><p>程序猿的生活中其实并非只有code，我们还有诗和远方 ~~~</p></div></div></div><ul class="social-links"><li><a href="http://www.jianshu.com/u/d35e7ed50e98"><i class="fa fa-jianshu"></i></a></li><li><a href="https://github.com/Kinglions"><i class="fa fa-github"></i></a></li><li><a href="https://kinglions.coding.me"><i class="fa fa-coding"></i></a></li><li><a href="http://weibo.com/u/5183524910"><i class="fa fa-weibo"></i></a></li><li><a href="mailto:kinglionsfrank@163.com"><i class="fa fa-emil"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by</span></a><a href="http://www.jianshu.com/u/d35e7ed50e98"> KingLionsFrank</a><span>&</span><a href="https://github.com/Kinglions"> Frank</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/logo.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>RunTime的了解与使用</a></h3></div><div class="post-content"><p>runtime这个词对于iOS程序猿童鞋来说，都是一个“耳熟能详”的名词，因为runtime就像面试中的“诅咒”一样，每当遇到相关面试题，都是几家欢喜几家愁。那么runtime到底是什么呢？<br>runtime是 OC底层的一套C语言的API，编译器最终都会将OC代码转化为运行时代码。不过苹果已经将 ObjC runtime 代码开源了，我们可以下面的网址浏览源代码：<br><a href="http://opensource.apple.com/source/objc4/objc4-493.9/runtime/" target="_blank" rel="external">http://opensource.apple.com/source/objc4/objc4-493.9/runtime/</a><br>那么我们就先通过一些经典的面试题来了解一些runtime这个“诅咒”的威力：</p>
<p>1、下面代码输出结果是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">@implementation Son : Father</div><div class="line">- (id)init &#123;</div><div class="line">    self = [super init];</div><div class="line">    if (self) &#123;</div><div class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([self class]));</div><div class="line">        NSLog(@&quot;%@&quot;, NSStringFromClass([super class]));</div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>答案： <code>(1) Son / Son 因为super为编译器标示符，向super发送的消息被编译成objc_msgSendSuper，但仍以self作为receiver</code></p>
<p>2、下面代码输出结果是什么？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">BOOL res1 = [(id)[NSObject class] isKindOfClass:[NSObject class]];</div><div class="line">BOOL res2 = [(id)[NSObject class] isMemberOfClass:[NSObject class]];</div><div class="line">BOOL res3 = [(id)[Sark class] isKindOfClass:[Sark class]];</div><div class="line">BOOL res4 = [(id)[Sark class] isMemberOfClass:[Sark class]];</div></pre></td></tr></table></figure>
<p>答案： <code>(2) YES / NO / NO / NO &lt;NSObject&gt;协议有一套类方法的隐藏实现，所以编译运行正常；由于NSObject meta class的父类为NSObject class，所以只有第一句为YES</code><br>(3) 下面的代码会？Compile Error / Runtime Crash / NSLog…?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">@interface NSObject (Sark)</div><div class="line">+ (void)foo;</div><div class="line">@end</div><div class="line">@implementation NSObject (Sark)</div><div class="line">- (void)foo &#123;</div><div class="line">    NSLog(@&quot;IMP: -[NSObject (Sark) foo]&quot;);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line">// 测试代码</div><div class="line">[NSObject foo];</div><div class="line">[[NSObject new] foo];</div></pre></td></tr></table></figure>
<p>答案 <code>(3) 编译运行正常，两行代码都执行-foo。 [NSObject foo]方法查找路线为 NSObject meta class –super-&gt; NSObject class，和第二题知识点很相似。</code></p>
<p>(4) 下面的代码会？Compile Error / Runtime Crash / NSLog…?</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line">@interface Sark : NSObject</div><div class="line">@property (nonatomic, copy) NSString *name;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation Sark</div><div class="line">- (void)speak &#123;</div><div class="line">    NSLog(@&quot;my name&apos;s %@&quot;, self.name);</div><div class="line">&#125;</div><div class="line">@end</div><div class="line"></div><div class="line">@implementation ThirdViewController</div><div class="line">- (void)viewDidLoad &#123;</div><div class="line">    [super viewDidLoad];</div><div class="line">    id cls = [Sark class];</div><div class="line">    void *obj = &amp;cls;</div><div class="line">    [(__bridge id)obj speak];</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1616138-8690e4187f43c4f1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="效果.png"></p>
<p>答案: <code>编译运行正常，输出ThirdViewController中的self对象。 编译运行正常，调用了-speak方法，由于
id cls = [Sark class];
void *obj = &amp;cls;
obj已经满足了构成一个objc对象的全部要求（首地址指向ClassObject），所以能够正常走消息机制；
由于这个人造的对象在栈上，而取self.name的操作本质上是self指针在内存向高位地址偏移（32位下一个指针是4字节），按viewDidLoad执行时各个变量入栈顺序从高到底为（self, _cmd, self.class, self, obj）（前两个是方法隐含入参，随后两个为super调用的两个压栈参数），遂栈低地址的obj+4取到了self。</code><br>看到上面的几道面试题和答案，有些童鞋可能还是一头雾水，那下面就一点点的捋一捋runtime的功能：</p>
<p></p><h2>一：RunTime中的一些名词概念</h2><br>objc_msgSend函数定义如下:<br><code>id objc_msgSend(id self, SEL op, ...)</code><p></p>
<p></p><h4>（1）什么是 SEL？</h4><br>打开objc.h文件，看下SEL的定义如下:<br><code>typedef struct objc_selector *SEL</code><br><code>SEL</code>是一个指向<code>objc_selector</code>结构体的指针。而<code>objc_selector</code>的定义并没有在runtime.h中给出定义。我们可以尝试运行如下代码:<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">SEL sel = @selector(foo);</div><div class="line">NSLog(@&quot;%s&quot;, (char *)sel);</div><div class="line">NSLog(@&quot;%p&quot;, sel);</div><div class="line">const char *selName = [@&quot;foo&quot; UTF8String];</div><div class="line">SEL sel2 = sel_registerName(selName);</div><div class="line">NSLog(@&quot;%s&quot;, (char *)sel2);</div><div class="line">NSLog(@&quot;%p&quot;, sel2);</div></pre></td></tr></table></figure>
<p>输出如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">2014-11-06 13:46:08.058 Test[15053:1132268] foo</div><div class="line">2014-11-06 13:46:08.058 Test[15053:1132268] 0x7fff8fde5114</div><div class="line">2014-11-06 13:46:08.058 Test[15053:1132268] foo</div><div class="line">2014-11-06 13:46:08.058 Test[15053:1132268] 0x7fff8fde5114</div></pre></td></tr></table></figure>
<p>Objective-C在编译时，会根据方法的名字生成一个用来区分这个方法的唯一的一个ID。只要方法名称相同，那么它们的ID就是相同的。<br>所以两个类之间，不管它们是父类与子类的关系，还是之间没有这种关系，只要方法名相同，那么它的SEL就是一样的。每一个方法都对应着一个SEL。编译器会根据每个方法的方法名为那个方法生成唯一的SEL。这些SEL组成了一个Set集合，当我们在这个集合中查找某个方法时，只需要去找这个方法对应的SEL即可。<code>而SEL本质是一个字符串，所以直接比较它们的地址即可。</code><br>当然，不同的类可以拥有相同的selector。不同类的实例对象执行相同的selector时，会在各自的方法列表中去根据selector去寻找自己对应的<code>IMP</code>。</p>
<p></p><h4>（2）那么什么是<code>IMP</code>呢？继续看定义:</h4><br><code>typedef id (*IMP)(id, SEL, ...);</code><br><code>IMP本质就是一个函数指针，这个被指向的函数包含一个接收消息的对象id，调用方法的SEL，以及一些方法参数，并返回一个id。</code>因此我们可以通过<code>SEL</code>获得它所对应的<code>IMP</code>，在取得了函数指针之后，也就意味着我们取得了需要执行方法的代码入口，这样我们就可以像普通的C语言函数调用一样使用这个函数指针。<p></p>
<p></p><h4>（3）那么什么是Ivar呢？</h4><br>ivar 在objc中被定义为：<br><code>typedef struct objc_ivar *Ivar;</code><br>它是一个指向objc_ivar结构体的指针，结构体有如下定义：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct objc_ivar &#123;</div><div class="line">    char *ivar_name        OBJC2_UNAVAILABLE;</div><div class="line">    char *ivar_type          OBJC2_UNAVAILABLE;</div><div class="line">    int ivar_offset             OBJC2_UNAVAILABLE;</div><div class="line"> #ifdef __LP64__</div><div class="line">    int space                    OBJC2_UNAVAILABLE; #endif</div><div class="line">&#125; OBJC2_UNAVAILABLE;</div></pre></td></tr></table></figure>
<p></p><h4>（4）@Property</h4><br>类中的Property属性被编译器转换成了Ivar，并且自动添加了我们熟悉的Set和Get方法。<p></p>
<p></p><h4>（5）isa</h4><br>isa 是一个 objc_class 类型的指针，内存布局以一个 objc_class 指针为开始的所有东东都可以当做一个 object 来对待！ 这就是说 objc_class 或者说类其实也可以当做一个 objc_object 对象来对待！这里要区分清楚两个名词：<code>类对象（class object）</code>与<code>实例对象（instance object）</code>。ObjC还对<code>类对象</code>与<code>实例对象</code>中的 isa 所指向的类结构作了不同的命名：<br><code>类对象</code>中的 isa 指向类结构被称作 metaclass(元类)，metaclass 存储类的static类成员变量与static类成员方法（+开头的方法）；<br><code>实例对象</code>中的 isa 指向类结构称作 class（普通的），class 结构存储类的普通成员变量与普通成员方法（-开头的方法）。<p></p>
<p></p><h4>（6）super_class：</h4><br>一看就明白，指向该类的父类呗！如果该类已经是最顶层的根类（如 NSObject 或 NSProxy），那么 super_class 就为 NULL。<br>好，先中断一下其他类结构成员的介绍，让我们厘清一下在继承层次中，子类，父类，根类（这些都是普通 class）以及其对应的 metaclass 的 isa 与 super_class 之间关系:<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">规则一：类的实例对象的 isa 指向该类；该类的 isa 指向该类的 metaclass；</div><div class="line">规则二：类的 super_class 指向其父类，如果该类为根类则值为 NULL；</div><div class="line">规则三：metaclass 的 isa 指向根 metaclass，如果该 metaclass 是根 metaclass 则指向自身；</div><div class="line">规则四：metaclass 的 super_class 指向父 metaclass，如果该 metaclass 是根 metaclass 则指向该 metaclass 对应的类；</div></pre></td></tr></table></figure>
<p></p><h4>（7）那么 class 与 metaclass 的区别</h4><br>class 是 instance object 的类类型。当我们向实例对象发送消息（实例方法）时，我们在该实例对象的 class 结构的 methodlists 中去查找响应的函数，如果没找到匹配的响应函数则在该 class 的父类中的 methodlists 去查找（查找链为上图的中间那一排）。如下面的代码中，向str 实例对象发送 lowercaseString 消息，会在 NSString 类结构的 methodlists 中去查找 lowercaseString 的响应函数。<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">NSString * str;</div><div class="line">[str lowercaseString];</div></pre></td></tr></table></figure>
<p>metaclass 是 class object 的类类型。当我们向类对象发送消息（类方法）时，我们在该类对象的 metaclass 结构的 methodlists 中去查找响应的函数，如果没有找到匹配的响应函数则在该 metaclass 的父类中的 methodlists 去查找。如下面的代码中，向 NSString 类对象发送 stringWithString 消息，会在 NSString 的 metaclass 类结构的 methodlists 中去查找 stringWithString 的响应函数。<br><code>[NSString stringWithString:@&quot;str&quot;];</code></p>
<p></p><h2>二：Category添加属性</h2>category在我们实际开发过程中，是一个非常实用的得力助手，因为我们可以在不改变原有类的情况下进行方法拓展，但是有些时候，我们也需要为这些category分类添加一些属性供我们使用，问题就在这里，我们都知道：category分类无法直接添加属性，但是我们开发中又有这样的需求，这就尴尬啦~~~<br>首先我们先看一下，为什么在category中无法直接添加属性呢，category是表示一个指向分类的结构体的指针，其定义如下：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">struct objc_category &#123;</div><div class="line">    char *category_name  OBJC2_UNAVAILABLE;// 分类名</div><div class="line">    char *class_name OBJC2_UNAVAILABLE;// 分类所属的类名</div><div class="line">    struct objc_method_list *instance_methods OBJC2_UNAVAILABLE;// 实例方法列表</div><div class="line">    struct objc_method_list *class_methods OBJC2_UNAVAILABLE;// 类方法列表</div><div class="line">    struct objc_protocol_list *protocols OBJC2_UNAVAILABLE;// 分类所实现的协议列表</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在这个结构体主要包含了分类定义的实例方法与类方法，其中<code>instance_methods</code>列表是objc_class中方法列表的一个子集，而<code>class_methods</code>列表是元类方法列表的一个子集。<br>可发现，类别中没有ivar<code>(ivar代表类中实例变量的类型)</code>成员变量指针，也就意味着：类别中不能够添加实例变量和属性，<code>struct objc_ivar_list *ivars  OBJC2_UNAVAILABLE;// 该类的成员变量链表</code>简单的理解就是：在category中，系统无法自动为<code>@property</code>的属性生成 <code>set、get方法</code>。<br>【有些人可能就有疑惑了：为什么官方API和一些第三方的框架工具都有为category添加属性的现象呢？比如：NSIndexPath (UITableView)、MJRefresh等等】所以这是我们就需要使用到runtime为category关联一些属性对象。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> *通过键值对关联对象</div><div class="line"> * </div><div class="line"> * @param object  关联的对象源【通常为 self】</div><div class="line"> * @param key 唯一键，通过这个键进行取值【const void *是用来起到声明作用】</div><div class="line"> * @param value 值；“ key ”所对应的值</div><div class="line"> * @param policy 内存管理策略，枚举：objc_AssociationPolicy</div><div class="line"> * </div><div class="line"> * @see objc_setAssociatedObject</div><div class="line"> * @see objc_removeAssociatedObjects</div><div class="line"> */</div><div class="line">OBJC_EXPORT void objc_setAssociatedObject(id object, const void *key, id value, objc_AssociationPolicy policy)</div><div class="line">    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);</div><div class="line"></div><div class="line">/** </div><div class="line"> * 通过 key 获取关联值.</div><div class="line"> * </div><div class="line"> * @param object 关联的对象源【通常为 self】，在设置关联时所指定的与哪个对象关联的那个对象</div><div class="line"> * @param key 唯一键，在设置关联时所指定的键</div><div class="line"> * </div><div class="line"> * @return 返回唯一键对应的 value 值</div><div class="line"> * </div><div class="line"> * @see objc_setAssociatedObject</div><div class="line"> */</div><div class="line">OBJC_EXPORT id objc_getAssociatedObject(id object, const void *key)</div><div class="line">    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);</div><div class="line"></div><div class="line">/** </div><div class="line"> * 取消属性关联对象</div><div class="line"> * </div><div class="line"> * @param object 要取消关联属性的对象</div><div class="line"> * </div><div class="line"> * @see objc_setAssociatedObject</div><div class="line"> * @see objc_getAssociatedObject</div><div class="line"> */</div><div class="line">OBJC_EXPORT void objc_removeAssociatedObjects(id object)</div><div class="line">    OBJC_AVAILABLE(10.6, 3.1, 9.0, 1.0);</div></pre></td></tr></table></figure>
<p>其中的<code>关联策略</code>也是系统提供的一个枚举：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">typedef OBJC_ENUM(uintptr_t, objc_AssociationPolicy) &#123;</div><div class="line">    OBJC_ASSOCIATION_ASSIGN = 0,           /**表示弱引用关联，通常是基本数据类型 */</div><div class="line">    OBJC_ASSOCIATION_RETAIN_NONATOMIC = 1, /**表示强引用关联对象，是线程安全的； 如同：(nonatomic,strong) */</div><div class="line">    OBJC_ASSOCIATION_COPY_NONATOMIC = 3,   /**表示关联对象copy，是线程安全的； 如同：(nonatomic,copy) */</div><div class="line">    OBJC_ASSOCIATION_RETAIN = 01401,       /**表示强引用关联对象，不是线程安全的；  如同：(atomic,strong)*/</div><div class="line">    OBJC_ASSOCIATION_COPY = 01403          /**表示关联对象copy，不是线程安全的； 如同：(nonatomic,copy)  */</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>举个小栗子 ~</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">.h 中声明</div><div class="line">///通过runtime关联数组属性</div><div class="line">@property (nonatomic,strong)NSMutableArray * array;</div><div class="line"></div><div class="line">.m 中实现set、get 方法</div><div class="line">/// 设置属性关联</div><div class="line">-(void)setArray:(NSMutableArray *)array&#123;</div><div class="line">    objc_setAssociatedObject(self, @selector(array),</div><div class="line">                             array, OBJC_ASSOCIATION_RETAIN_NONATOMIC);</div><div class="line">&#125;</div><div class="line">-(NSMutableArray *)array&#123;</div><div class="line">    return objc_getAssociatedObject(self, @selector(array));</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><img src="http://upload-images.jianshu.io/upload_images/1616138-ac8b21c7a754aaa4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="设置调用关联属性.png"><br><img src="http://upload-images.jianshu.io/upload_images/1616138-f0243152a7989f42.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="set方法被调用.png"><br><img src="http://upload-images.jianshu.io/upload_images/1616138-42a9a3147f4a5562.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="get方法被调用.png"><br>当运行程序就可以发现：通过上面的runtime可以完美的为category关联我们需要的属性。</p>
<p></p><h2>三：方法交换</h2><br>说到方法交换，这个也是在实际开发中经常用到的一个技能，比如：对象默认调用的系统方法API，但是我们又需要对这个方法的调用及实现进行处理的情况下，就可以使用到<code>runtime</code>的方法交换<code>method_exchangeImplementations</code>进行实现这个需求。首先来看一些<code>runtime.h</code>中提供的几个方法：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line">/** </div><div class="line"> * 返回一个指定类对象实现的实例方法。</div><div class="line"> * </div><div class="line"> * @param cls 指定的类</div><div class="line"> * @param name 需要检索的方法</div><div class="line"> * </div><div class="line"> */</div><div class="line">OBJC_EXPORT Method class_getInstanceMethod(Class cls, SEL name)</div><div class="line">    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);</div><div class="line"></div><div class="line">/** </div><div class="line"> * 返回一个指定类对象实现的 类方法。</div><div class="line"> * </div><div class="line"> * @param cls 指定的类</div><div class="line"> * @param name 需要检索的方法</div><div class="line"> * </div><div class="line"> */</div><div class="line">OBJC_EXPORT Method class_getClassMethod(Class cls, SEL name)</div><div class="line">    OBJC_AVAILABLE(10.0, 2.0, 9.0, 1.0);</div><div class="line">/** </div><div class="line"> * 交换两个方法的实现.</div><div class="line"> * </div><div class="line"> * @param m1 方法与第二个方法交换。</div><div class="line"> * @param m2 方法与第一个方法交换。</div><div class="line"> * </div><div class="line"> */</div><div class="line">OBJC_EXPORT void method_exchangeImplementations(Method m1, Method m2) </div><div class="line">    OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0);</div></pre></td></tr></table></figure>
<p>举一个小栗子：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-be8817e2ec546172.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="类方法交换.png"><br><img src="http://upload-images.jianshu.io/upload_images/1616138-de4d9170217a1773.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="对象方法交换.png">从代码运行的效果可以看出：方法交换之后，再调用原来的 <code>eat 方法</code>，在实现过程中，就会默认进入到交换的 <code>goToSchool 方法</code>内。这就是关于<code>runtime</code>方法交换的一个简单示例，在实际开发中可以根据自己的需求进行实际操作啦！</p>
<p></p><h2>四：动态类型判断</h2>即运行时再决定对象的类型。这类动态特性在日常应用中非常常见，简单说就是id类型。id类型即通用的对象类，任何对象都可以被id指针所指，而在实际使用中，往往使用introspection来确定该对象的实际所属类：<br><code>- (BOOL)isMemberOfClass:(Class)aClass</code>是 NSObject 的方法，用以确定某个 NSObject 对象是否是某个类的成员。<br><code>- (BOOL)isKindOfClass:(Class)aClass</code>是用以确定某个对象是不是某个类或其子类的成员；例如：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">id obj = someInstance;</div><div class="line">if ([obj isKindOfClass:someClass])</div><div class="line">&#123;</div><div class="line">    someClass *classSpecifiedInstance = (someClass *)obj;</div><div class="line">    // Do Something to classSpecifiedInstance which now is an instance of someClass</div><div class="line">    //...</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p></p><h3>五：动态绑定方法</h3>首先先看一下系统提供的动态绑定相关的几个方法：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div></pre></td><td class="code"><pre><div class="line"> /**</div><div class="line"> 当这个类被调用了一个没有实现的方法时，会调用到这里</div><div class="line"> @param sel 未实现的类方法名</div><div class="line"> */</div><div class="line">+ (BOOL)resolveClassMethod:(SEL)sel  OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0);</div><div class="line">/**</div><div class="line"> 当这个类被调用了一个没有实现的对象</div><div class="line"> @param sel 未实现的对象方法名</div><div class="line"> */</div><div class="line">+ (BOOL)resolveInstanceMethod:(SEL)sel OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0);</div><div class="line">/**</div><div class="line">     动态添加</div><div class="line">     class_addMethod([self class], @selector(resolveThisMethodDynamically), (IMP) myMethodIMP, &quot;v@:&quot;);</div><div class="line">     </div><div class="line">     1、Class cls：类的类型</div><div class="line">     2、name：方法标记 sel</div><div class="line">     3、imp：方法的实现，是一个 函数指针</div><div class="line">     4、type：返回值类型</div><div class="line">     */</div><div class="line">OBJC_EXPORT BOOL class_addMethod(Class cls, SEL name, IMP imp,  const char *types)   OBJC_AVAILABLE(10.5, 2.0, 9.0, 1.0);</div><div class="line"></div><div class="line">/**</div><div class="line">上述添加方法中的 IMP imp 所对应的函数格式如下：</div><div class="line">*/</div><div class="line">void myMethodIMP(id self, SEL _cmd)</div><div class="line">&#123;</div><div class="line">    // implementation ....</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>动态绑定所做的，即是在实例所属类确定后，将某些属性和相应的方法绑定到实例上。这里所指的属性和方法当然包括了原来没有在类中实现的，而是在运行时才需要的新加入的实现。在Cocoa层，我们一般向一个NSObject对象发送-respondsToSelector:或者-instancesRespondToSelector:等来确定对象是否可以对某个SEL做出响应，而在OC消息转发机制被触发之前，对应的类的+resolveClassMethod:和+resolveInstanceMethod:将会被调用，在此时有机会动态地向类或者实例添加新的方法，也即类的实现是可以动态绑定的。举个小栗子：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-806ee50f82e0c103.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="动态添加方法.png">从运行结果上可以看出：当对象调用一个该类没有的方法时，系统会自动调用<code>resolveInstanceMethod :</code>方法，然后我们可以使用<code>class_addMethod</code>方法进行动态绑定，从而达到预期效果。<br>其中需要注意的是：<code>performSelector:  withObject: 方法</code>，因为调用这个方法时，系统在编译时是不会进行校验方法是否存在，只有在运行时才会进行查询方法。而直接调用方法时，在编译过程中就会进行校验方法是否存在。</p>
<p></p><h3>六：获取对象属性</h3><br>最典型的用法就是一个对象在<code>归档 encodeWithCoder</code>和<code>解档initWithCoder:</code>方法中需要该对象所有的属性进行<code>encodeObject:</code>和<code>decodeObjectForKey:</code>，通过runtime我们声明中无论写多少个属性，都不需要再修改实现中的代码了。<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">获得某个类的所有成员变量（outCount 会返回成员变量的总数）</div><div class="line">参数：</div><div class="line">/**</div><div class="line">1、哪个类</div><div class="line">2、放一个接收值的地址，用来存放属性的个数</div><div class="line">3、返回值：存放所有获取到的属性，通过下面两个方法可以调出名字和类型</div><div class="line">*/</div><div class="line">Ivar *class_copyIvarList(Class cls , unsigned int *outCount)</div><div class="line">//获得成员变量的名字</div><div class="line">const char *ivar_getName(Ivar v)</div><div class="line">//获得成员变量的类型（除了基本数据类型）</div><div class="line">const char *ivar_getTypeEndcoding(Ivar v)</div></pre></td></tr></table></figure>
<p>举个小栗子：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div></pre></td><td class="code"><pre><div class="line">// C语言内  但凡看到 copy creat new 需要释放</div><div class="line">// ARC</div><div class="line">// 告诉系统归档哪些东西</div><div class="line">- (void)encodeWithCoder:(NSCoder *)coder</div><div class="line">&#123;</div><div class="line">    unsigned int count = 0;</div><div class="line">    Ivar * ivars = class_copyIvarList([Person class], &amp;count);</div><div class="line">    for (int i = 0; i &lt; count; i ++) &#123;</div><div class="line">        //取出对应的成员Ivar</div><div class="line">        Ivar ivar = ivars[i];</div><div class="line">        const char * name = ivar_getName(ivar);</div><div class="line">        const char *type = ivar_getTypeEncoding(ivar);</div><div class="line">        NSLog(@&quot;成员变量名：%s 成员变量类型：%s&quot;,name,type);</div><div class="line">        </div><div class="line">        NSString * key = [NSString stringWithUTF8String:name];</div><div class="line">        //归档</div><div class="line">        [coder encodeObject:[self valueForKey:key] forKey:key];</div><div class="line">    &#125;</div><div class="line">    free(ivars);</div><div class="line">&#125;</div><div class="line">//解档</div><div class="line">- (instancetype)initWithCoder:(NSCoder *)coder</div><div class="line">&#123;</div><div class="line">    if (self =[super init]) &#123;</div><div class="line">        unsigned int count = 0;</div><div class="line">        Ivar * ivars = class_copyIvarList([Person class], &amp;count);</div><div class="line">        for (int i = 0; i &lt; count; i ++) &#123;</div><div class="line">            //取出对应的成员Ivar</div><div class="line">            Ivar ivar = ivars[i];</div><div class="line">            const char * name = ivar_getName(ivar);</div><div class="line">            NSString * key = [NSString stringWithUTF8String:name];</div><div class="line">            //解档</div><div class="line">            id value = [coder decodeObjectForKey:key];</div><div class="line">            //设置到属性身上</div><div class="line">            [self setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line">        free(ivars);</div><div class="line">        </div><div class="line">    &#125;</div><div class="line">    return self;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这就是使用<code>runtime</code>实现的归档解档方法。</p>
<p></p><h3>七：字典转模型</h3><br>字典转模型这个在实际开发中也是最常用的，因为当我们网络请求到数据后，我们就需要将数据转化为对应的对象模型。不过现在有比较成熟的字典转模型框架，比如：<code>YYModel</code>、<code>MJExtension</code>等，那我们如何利用<code>runtime</code>实现自己的字典转模型框架呢？举个小栗子：<p></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">NSObject+Runtime_Model.h 代码逻辑：</div><div class="line"></div><div class="line">@interface NSObject (Runtime_Model)</div><div class="line">/** 字典转模型</div><div class="line"> 使用该方法进行字典转模型时，如果使用了设置属性名字与返回的 key 不同时，</div><div class="line"> 需要实现 - (void)setValue:(id)value forUndefinedKey:(NSString *)key 方法，进行转化</div><div class="line"> */</div><div class="line">+ (instancetype)objectWithDict:(NSDictionary *)dict;</div><div class="line">@end</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div><div class="line">57</div><div class="line">58</div><div class="line">59</div><div class="line">60</div><div class="line">61</div><div class="line">62</div><div class="line">63</div><div class="line">64</div><div class="line">65</div><div class="line">66</div><div class="line">67</div><div class="line">68</div><div class="line">69</div><div class="line">70</div><div class="line">71</div><div class="line">72</div><div class="line">73</div><div class="line">74</div><div class="line">75</div><div class="line">76</div><div class="line">77</div><div class="line">78</div><div class="line">79</div><div class="line">80</div><div class="line">81</div><div class="line">82</div><div class="line">83</div><div class="line">84</div><div class="line">85</div><div class="line">86</div><div class="line">87</div><div class="line">88</div><div class="line">89</div><div class="line">90</div><div class="line">91</div><div class="line">92</div><div class="line">93</div><div class="line">94</div><div class="line">95</div><div class="line">96</div><div class="line">97</div><div class="line">98</div><div class="line">99</div><div class="line">100</div><div class="line">101</div><div class="line">102</div><div class="line">103</div><div class="line">104</div><div class="line">105</div><div class="line">106</div><div class="line">107</div><div class="line">108</div><div class="line">109</div><div class="line">110</div><div class="line">111</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">NSObject+Runtime_Model.m 代码逻辑：</div><div class="line"></div><div class="line">#import &quot;NSObject+Runtime_Model.h&quot;</div><div class="line">#import &lt;objc/runtime.h&gt;</div><div class="line"></div><div class="line">@implementation NSObject (Runtime_Model)</div><div class="line">// 字典转模型</div><div class="line">+ (instancetype)objectWithDict:(NSDictionary *)dict&#123;</div><div class="line">    // 创建对应模型对象</div><div class="line">    id objc = [[self alloc] init];</div><div class="line">    </div><div class="line">    // 判断字典中的 key 是否为成员变量，以便为成员变量进行替换赋值</div><div class="line">    for (NSString * key in dict.allKeys) &#123;</div><div class="line">        </div><div class="line">        id value = dict[key];</div><div class="line">        </div><div class="line">        /*判断当前属性是不是Model*/</div><div class="line">        objc_property_t property = class_getProperty([self class], key.UTF8String);</div><div class="line">        unsigned int outCount = 0;</div><div class="line">        objc_property_attribute_t * attributeList = property_copyAttributeList(property, &amp;outCount);</div><div class="line">        </div><div class="line">        if (!attributeList) &#123;// 属于模型的属性</div><div class="line">            </div><div class="line">            if ([objc respondsToSelector:@selector(setValue:forUndefinedKey:)]) &#123;</div><div class="line">                [objc setValue:value forUndefinedKey:key];</div><div class="line">            &#125;</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    unsigned int count = 0;</div><div class="line">    </div><div class="line">    // 1.获取成员属性数组</div><div class="line">    Ivar *ivarList = class_copyIvarList(self, &amp;count);</div><div class="line">    </div><div class="line">    // 2.遍历所有的成员属性名,一个一个去字典中取出对应的value给模型属性赋值</div><div class="line">    for (int i = 0; i &lt; count; i++) &#123;</div><div class="line">        </div><div class="line">        // 2.1 获取成员属性</div><div class="line">        Ivar ivar = ivarList[i];</div><div class="line">        </div><div class="line">        // 2.2 获取成员属性名 C -&gt; OC 字符串</div><div class="line">        NSString *ivarName = [NSString stringWithUTF8String:ivar_getName(ivar)];</div><div class="line">        </div><div class="line">        // 2.3 _成员属性名 =&gt; 字典key</div><div class="line">        NSString *key = [ivarName substringFromIndex:1];</div><div class="line">        </div><div class="line">        // 2.4 去字典中取出对应value给模型属性赋值</div><div class="line">        id value = dict[key];</div><div class="line">        </div><div class="line">        // 属性对应的类名</div><div class="line">        const char *type = ivar_getTypeEncoding(ivar);</div><div class="line">        </div><div class="line">        // 获取成员属性类型</div><div class="line">        NSString *ivarType = [NSString stringWithUTF8String:type];</div><div class="line">        </div><div class="line">        // 二级转换,字典中还有字典,也需要把对应字典转换成模型</div><div class="line">        //</div><div class="line">        // 判断下value,是不是字典</div><div class="line">        if ([value isKindOfClass:[NSDictionary class]] &amp;&amp; ![ivarType containsString:@&quot;NS&quot;]) &#123; //  是字典对象,并且属性名对应类型是自定义类型</div><div class="line">            // user User</div><div class="line">            </div><div class="line">            // 处理类型字符串 @\&quot;User\&quot; -&gt; User</div><div class="line">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;];</div><div class="line">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\&quot;&quot; withString:@&quot;&quot;];</div><div class="line">            // 自定义对象,并且值是字典</div><div class="line">            // value:user字典 -&gt; User模型</div><div class="line">            // 获取模型(user)类对象</div><div class="line">            Class modalClass = NSClassFromString(ivarType);</div><div class="line">            </div><div class="line">            // 字典转模型</div><div class="line">            if (modalClass) &#123;</div><div class="line">                // 字典转模型 user</div><div class="line">                value = [modalClass objectWithDict:value];</div><div class="line">            &#125;</div><div class="line">            </div><div class="line">            // 字典,user</div><div class="line">            //            NSLog(@&quot;%@&quot;,key);</div><div class="line">        &#125;</div><div class="line">        </div><div class="line">        // 三级转换：NSArray中也是字典，把数组中的字典转换成模型.</div><div class="line">        // 判断值是否是数组</div><div class="line">        if ([value isKindOfClass:[NSArray class]]) &#123;</div><div class="line">            </div><div class="line">            // 转换成id类型，就能调用任何对象的方法</div><div class="line">            id idSelf = self;</div><div class="line">            </div><div class="line">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;@&quot; withString:@&quot;&quot;];</div><div class="line">            ivarType = [ivarType stringByReplacingOccurrencesOfString:@&quot;\&quot;&quot; withString:@&quot;&quot;];</div><div class="line">            </div><div class="line">            // 生成模型</div><div class="line">            Class classModel = NSClassFromString(ivarType);</div><div class="line">            NSMutableArray *arrM = [NSMutableArray array];</div><div class="line">            // 遍历字典数组，生成模型数组</div><div class="line">            for (NSDictionary *dict in value) &#123;</div><div class="line">                // 字典转模型</div><div class="line">                id model =  [classModel objectWithDict:dict];</div><div class="line">                [arrM addObject:model];</div><div class="line">            &#125;</div><div class="line">            // 把模型数组赋值给value</div><div class="line">            value = arrM;</div><div class="line">            </div><div class="line">        &#125;</div><div class="line">        // 2.5 KVC字典转模型</div><div class="line">        if (value) &#123;</div><div class="line">            [objc setValue:value forKey:key];</div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">    // 返回对象</div><div class="line">    return objc;</div><div class="line">&#125;</div><div class="line">@end</div></pre></td></tr></table></figure>
<p>当然这也只是<code>RunTime</code>的一部分功能，但却是在实际开发中经常用到的知识点。所以如果想要继续拓展<code>RunTime</code>技能深度的话，可以翻看苹果开源的<code>RunTime</code>源码<a href="http://opensource.apple.com/source/objc4/objc4-493.9/runtime/" target="_blank" rel="external">http://opensource.apple.com/source/objc4/objc4-493.9/runtime/</a><br><code>参考 ：http://devclub.cc/article?articleId=Vn/22T2qcRg1HT4927IyyA==</code></p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-03-17</span><i class="fa fa-comment-o"></i><a href="/2017/03/17/RunTime的了解与使用/#comments">评论</a><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a role="navigation" href="/2017/03/13/正则初体验/" title="正则初体验" class="btn">下一篇</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'kinglionsfrank';
var disqus_identifier = '2017/03/17/RunTime的了解与使用/';
var disqus_title = 'RunTime的了解与使用';
var disqus_url = 'https://Kinglions.github.io/2017/03/17/RunTime的了解与使用/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//kinglionsfrank.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>