<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="kinglionsfrank@163.com"><title>浅谈iOS中多线程开发 · Frank(不羁放荡爱自由)</title><meta name="description" content="目录：（一）线程与进程之间的区别（二）为什么需要学习多线程（三）多线程任务执行方式（四）多线程执行的原理（五）多线程的优缺点（六）在iOS开发中的多线程实现技术方案
（A）PThread
（B）NSThread
（C）GCD
（1） dispatch_get_global_queue 探究
（2）d"><meta name="keywords" content="Hexo,HTML,Frank,CSS,iOS,苹果"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo.png" style="width:127px;"><h4 title=""><a href="/">Frank(不羁放荡爱自由)</a></h4><div class="description"><p>程序猿的生活中其实并非只有code，我们还有诗和远方 ~~~</p></div></div></div><ul class="social-links"><li><a href="http://www.jianshu.com/u/d35e7ed50e98"><i class="fa fa-jianshu"></i></a></li><li><a href="https://github.com/Kinglions"><i class="fa fa-github"></i></a></li><li><a href="https://kinglions.coding.me"><i class="fa icon-coding-copy"></i></a></li><li><a href="http://weibo.com/u/5183524910"><i class="fa fa-weibo"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by</span></a><a href="http://www.jianshu.com/u/d35e7ed50e98"> KingLionsFrank</a><span>&</span><a href="https://github.com/Kinglions"> Frank</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="/images/logo.png"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>浅谈iOS中多线程开发</a></h3></div><div class="post-content"><p>目录：<br><br><a href="#(一)">（一）线程与进程之间的区别</a><br><a href="#(二)">（二）为什么需要学习多线程</a><br><a href="#(三)">（三）多线程任务执行方式</a><br><a href="#(四)">（四）多线程执行的原理</a><br><a href="#(五)">（五）多线程的优缺点</a><br><a href="#(六)">（六）在iOS开发中的多线程实现技术方案</a></p>
<p><li><a href="#(A)">（A）PThread</a></li></p>
<p><li><a href="#(B)">（B）NSThread</a></li></p>
<p><li><a href="#(C)">（C）GCD</a></li></p>
<p><ul><a href="#(1)">（1） dispatch_get_global_queue 探究</a></ul></p>
<p><ul><a href="#(2)">（2）dispatch_group的探索</a></ul></p>
<p><ul><a href="#(3)">（3）dispatch_once探究</a></ul></p>
<p><ul><a href="#(4)">（4）dispatch_after探究</a></ul></p>
<p><li><a href="#(D)">（D）NSOperation</a></li></p>
<p><ul><a href="#(D1)">（1）NSInvocationOperation探究</a></ul></p>
<p><ul><a href="#(D2)">（2）NSBlockOperation探究</a></ul></p>
<p><ul><a href="#(D3)">（3）NSOperationQueue探究</a></ul></p>
<p><ul><a href="#(D4)">（4）自定义NSOperation子类探究</a></ul></p>
<p><ul><a href="#(D4.1)">（4.1）maxConcurrentOperationCount 属性</a></ul></p>
<p><ul><a href="#(D4.2)">（4.2）addDependency 方法添加依赖：</a></ul><br><a href="#(七)">（七）线程锁相关</a><br><br><a href="#(八)">（八）总结</a><br><br></p>
<p>【文章篇幅有点偏多，有兴趣的可以继续读下去】<br>一般说到线程，那么首先要区分一下<code>线程</code>与<code>进程</code>，首先来简单的区分一下两者的关系</p>
<p><strong>进程：</strong>是具有一定独立功能的程序关于某个数据集合上的一次运行活动，进程是系统进行资源分配和调度的一个独立单位。<br><strong>线程：</strong>是指进程内的一个执行单元，也是进程内的可调度实体。是进程的一个实体，是CPU调度和分派的基本单位，他是比进程更小的能独立运行的基本单位，线程自己基本上不拥有系统资源，只拥有一点在运行中必不可少的资源（寄存器，栈，程序计数器），但是它可与同一个进程的其他线程共享进程所拥有的全部资源<br><br><a name="(一)">（一）线程与进程之间的区别</a><br></p>
<p>（1）地址空间：进程内的一个执行单元，进程至少包含一个线程，他们共享进程的地址空间，而进程有自己独立的地址空间<br>（2）资源拥有：进程是资源分配和拥有的单位，同一个进程内的线程共享进程资源 <code>【进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其它进程产生影响，而线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉，所以多进程的程序要比多线程的程序健壮，但在进程切换时，耗费资源较大，效率要差一些。但对于一些要求同时进行并且又要共享某些变量的并发操作，只能用线程，不能用进程。】</code><br>（3）线程是处理器调度的基本单位，但进程不是<br>（4）二者皆可并发执行<br><br><a name="(二)">（二）为什么需要学习多线程</a><br><br>因为在程序运行中，对于<code>网络请求、图片加载、文件处理、数据存储、任务执行等等</code>这些操作都需要放到异步线程中进行处理，这也显得多线程的重要性<br><br><a name="(三)">（三）多线程任务执行方式</a><br><br>主要分为两种：<code>串行</code>和<code>并行</code></p>
<p><strong>串行：</strong>（简易）指的是多个任务按照一定顺序执行（任务执行有顺序依赖关系），例如有三个任务执行，并且需要的执行顺序是 <code>线程1-&gt;线程2-&gt;线程3</code>，那么这三个任务执行完毕所需的时间就是 t1 + t2 + t3<br><img src="http://upload-images.jianshu.io/upload_images/1616138-80989a3e27f0b56d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="串行.png"></p>
<p><strong>并行：</strong>（简易）并发执行多个任务（任务执行没有顺序依赖关系），例如有三个任务执行，假设任务2的执行时间最长，那么这三个任务执行完毕所需的时间就是 t2<br><img src="http://upload-images.jianshu.io/upload_images/1616138-12551189196b4c21.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="并行.png"><br>有一点需要明白的是：两种任务执行方式并没有好坏之分的，只是根据自己的需求进行选择使用<code>并行执行</code>还是<code>串行执行</code><br><a name="(四)">（四）多线程执行的原理</a><br><img src="http://upload-images.jianshu.io/upload_images/1616138-b6bdb3e45a7005b9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单核操作系统执行多线程.png"><br>在单核操作系统的多线程执行，其实是采用时间片轮转调度来实现的，操作系统会采用时间片轮转调度的方式为每一个线程间接性的分配时间执行任务，当线程1执行的时候，线程2就处于阻塞或者空闲的状态，当时间片执行到线程2时，执行循序有会反过来，所以对于单核操作系统来说的多线程执行方式就是：<code>宏观上的并行，微观上的串行</code><br><img src="http://upload-images.jianshu.io/upload_images/1616138-a8ec7613f54c049b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="多核操作系统执行多线程.png"><br>对于多核操作系统来说，就可以达到并行执行的效果，因为每一个处理器都会按照时间片轮转的方式执行任务，多个核心处理器就可以实现多个任务同时执行的效果<br><br><a name="(五)">（五）多线程的优缺点</a><br><br><strong>优点：</strong><br>（1）简化了变成模型：可以将原本放在一个线程中执行的一些耗时或较为大的任务进行分割到多个线程中执行<br>（2）更加轻量级<br>（3）提高了执行效率<br>（4）提高资源利用率<br><strong>缺点：</strong><br>（1）增加了程序设计的复杂性：因为在多线程中我们需要处理的最大问题就是<code>资源共享问题</code>和<code>数据读写问题</code>，如果两个线程同时修改同一个数据或属性，就会出现问题，所以在一定程度上增加了程序设计的复杂性<br>（2）占用内存空间：因为如果不分场合随意使用多线程的时候，会导致程序内存的增加，这对客户端开发来说是一个绝对不能忽视的问题，所以我们需要适度、合理的使用多线程开发<br>（3）增加CPU调度开销：因为在多线程执行任务时，是使用时间片调度的方式进行的，频繁的切换时间片，必然会增大CPU的调度开销<br><br><a name="(六)">（六）在iOS开发中的多线程实现技术方案</a><br><img src="http://upload-images.jianshu.io/upload_images/1616138-8fc8e995e0f9e2ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="iOS多线程实现技术方法.png"><br>下面就通过Demo对这四种方式进行一一解释<br><br><a name="(A)">（A）PThread</a><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line">#pragma mark ---- 测试 pThread</div><div class="line">/**</div><div class="line">测试 pThread</div><div class="line">*/</div><div class="line">- (IBAction)runPThread:(id)sender &#123;</div><div class="line"></div><div class="line">NSLog(@&quot;我是在主线程中执行\n\n&quot;);</div><div class="line">pthread_t pthread;</div><div class="line"></div><div class="line">pthread_create(&amp;pthread, NULL, run, NULL);</div><div class="line">&#125;</div><div class="line">/**</div><div class="line">C语言函数</div><div class="line">*/</div><div class="line">void * run(void * data)&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;我是在子线程中执行\n\n&quot;);</div><div class="line"></div><div class="line">for (int i = 1; i &lt;= 10; i++) &#123;</div><div class="line"></div><div class="line">NSLog(@&quot;%d \n\n&quot;,i);</div><div class="line">sleep(1);</div><div class="line">&#125;</div><div class="line"></div><div class="line">return NULL;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>从代码中可以看出pThread的创建执行其实也是比较简单的，不过实现过程是通过C语言进行的，从创建方法<code>pthread_create(&lt;#pthread_t  _Nullable *restrict _Nonnull#&gt;, &lt;#const pthread_attr_t *restrict _Nullable#&gt;, &lt;#void * _Nullable (* _Nonnull)(void * _Nullable)#&gt;, &lt;#void *restrict _Nullable#&gt;)</code>可以看出，第一个参数是需要一个pthread 对象指针，第三个是需要一个C语言函数方法（就当于OC中绑定的执行方法），至于第二个和第四个参数，暂时没有什么用（其实偶也不晓得什么作用）可以直接传入<code>NULL</code><br><img src="http://upload-images.jianshu.io/upload_images/1616138-5da6088181a2dcc8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="pthread运行结果.png"><br>从打印结果中可以看出和我们预期的结果相同，成功的开启了一个子线程<br>细心地童鞋可以会发现图中红色箭头指向的两组数字，其实在我们的输出控制台输出的都有这两组数字，但是很多朋友可能并没有注意过这些，也不知道是什么意思？！<br><img src="http://upload-images.jianshu.io/upload_images/1616138-9bcbabd279042e44.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="控制台.png"><br>其实第一组数字<code>24592</code>表示的是当前程序所处的 <code>进程 ID</code>，而第二组数字<code>1923132</code>则表示当前所处的<code>线程 ID</code>，所以我们就可以通过<code>线程ID</code>进行判断是否成功开启了一个子线程<br><br><a name="(B)">（B）NSThread</a><br><br>NSThread可能是我们在OC开发中接触最早的多线程实现技术，而且NSThread的实现多线程的方式也有三种，下面就通过代码做解释</p>
<p>NSThread的实现方式一：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#pragma mark ---- 测试 NSThread</div><div class="line">/**</div><div class="line">测试 NSThread</div><div class="line">*/</div><div class="line">- (IBAction)runNSThread:(id)sender &#123;</div><div class="line">NSLog(@&quot;我是在主线程中执行\n&quot;);</div><div class="line">/*</div><div class="line">创建方式 1 ：通过 alloc initWithTarget 进行创建</div><div class="line">好处：可以通过 NSThread 对象设置一些线程属性；例如线程 名字</div><div class="line">*/</div><div class="line">NSThread * thread1 = [[NSThread alloc]initWithTarget:self selector:@selector(runThread1) object:nil];</div><div class="line">[thread1 setName:@&quot;Name_Thread1&quot;];// 设置线程名字</div><div class="line">[thread1 setThreadPriority:0.1];// 设置线程优先级</div><div class="line">[thread1 start];</div><div class="line"></div><div class="line">NSThread * thread2 = [[NSThread alloc]initWithTarget:self selector:@selector(runThread1) object:nil];</div><div class="line">[thread2 setName:@&quot;Name_Thread2&quot;];// 设置线程名字</div><div class="line">[thread2 setThreadPriority:0.5];// 设置线程优先级</div><div class="line">[thread2 start];</div><div class="line">&#125;</div><div class="line">/// 方式一</div><div class="line">-(void)runThread1&#123;</div><div class="line">for (int i = 11; i &lt;= 20; i++) &#123;</div><div class="line"></div><div class="line">NSLog(@&quot;%d -- %@&quot;,i,[NSThread currentThread].name);</div><div class="line">sleep(1);</div><div class="line">if (i == 20) &#123;</div><div class="line">[self performSelectorOnMainThread:@selector(runMainThread) withObject:nil waitUntilDone:YES];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">-(void)runMainThread&#123;</div><div class="line">NSLog(@&quot; 回调主线程&quot;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1616138-5c574fc4cfa75d77.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSThread方式一.png"><br>方式一是通过 alloc initWithTarget 进行创建，这种方式的好处是可以通过 NSThread 对象设置一些线程属性；例如线程 名字，从控制台信息可以看出来，当设置了不同的NSThread对象的优先级属性，可以控制其执行的顺序，优先级越高，越先执行；而设置名字属性后，可以通过调试监控当前所处线程，便于问题分析</p>
<p>NSThread的实现方式二：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 创建方式 2 ：通过 detachNewThreadSelector 方式创建并执行线程</div><div class="line">[NSThread detachNewThreadSelector:@selector(runThread2) toTarget:self withObject:nil];</div></pre></td></tr></table></figure></p>
<p>/// 方式二绑定方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">-(void)runThread2&#123;</div><div class="line">NSLog(@&quot;我是在子线程中执行\n\n&quot;);</div><div class="line">for (int i = 11; i &lt;= 20; i++) &#123;</div><div class="line">NSLog(@&quot;%d \n\n&quot;,i);</div><div class="line">sleep(1);</div><div class="line">if (i == 20) &#123;</div><div class="line">[self performSelectorOnMainThread:@selector(runMainThread) withObject:nil waitUntilDone:YES];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1616138-de7fef1563fcaa6f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSThread方式二.png"></p>
<p>NSThread的实现方式三：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">// 创建方式 3 ：通过 performSelectorInBackground 方式创建并执行线程</div><div class="line">[self performSelectorInBackground:@selector(runThread3) withObject:nil];</div></pre></td></tr></table></figure></p>
<p>/// 方式三绑定方法<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">/// 方式三</div><div class="line">-(void)runThread3&#123;</div><div class="line">NSLog(@&quot;我是在子线程中执行\n&quot;);</div><div class="line">for (int i = 21; i &lt;= 30; i++) &#123;</div><div class="line">NSLog(@&quot;%d \n&quot;,i);</div><div class="line">sleep(1);</div><div class="line">if (i == 30) &#123;</div><div class="line">[self performSelectorOnMainThread:@selector(runMainThread) withObject:nil waitUntilDone:YES];</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1616138-3473e252bf42b726.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSThread方式三.png"><br>在三组控制台输出结果对比可以发现，三种方式都能达到预期效果<br><br><a name="(C)">（C）GCD</a><br><br>关于GCD可能也是我们开发过程中使用最多的一种方式，但是大多数可能都只是<code>只知其一，不知其二</code>，会用其中一两个方法，就觉得会用GCD啦，其实这是远远不够的，那我们就一起来探讨一下GCD的强大之处：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">1、GCD的描述：</div><div class="line">纯C语言开发，是苹果公司为多核的并行运算提出的解决方案，会自动利用更多的CPU内核（比如双核、四核），可以自动管理线程的生命周期（创建线程、调度任务、销毁线程）。</div><div class="line">2、GCD的两个核心</div><div class="line">2.1 任务</div><div class="line">执行的操作,在GCD中，任务是通过 block来封装的。并且任务的block没有参数也没有返回值。</div><div class="line">2.2 队列存放任务包括</div><div class="line">串行队列</div><div class="line">并发队列</div><div class="line">主队列</div><div class="line">全局队列</div></pre></td></tr></table></figure></p>
<p>首先还是像上面一样通过简单Demo看看它的基本功能：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">#pragma mark ---- 测试 GCD</div><div class="line">- (IBAction)runGCD:(id)sender &#123;</div><div class="line">NSLog(@&quot;执行 GCD&quot;);</div><div class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">NSLog(@&quot; start tast 1&quot;);</div><div class="line">// 执行耗时任务</div><div class="line">[NSThread sleepForTimeInterval:3];</div><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line"></div><div class="line">NSLog(@&quot;回调主线程刷新UI&quot;);</div><div class="line">&#125;);</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>打印结果：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-e209f26660b88aee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GCD打印输出.png"><br>同样能够实现这样的功能，接下来就一步步的来具体分析GCD：<br><br><a name="(1)">(1) dispatch_get_global_queue 探究：</a><br><br><img src="http://upload-images.jianshu.io/upload_images/1616138-ef24cda196594967.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GCD测试1.png"><br>由打印信息可以看出，三个线程是同一时间开始执行，同一时间结束执行的，<br><code>这就说明GCD中的dispatch_get_global_queue是全局并发的队列</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">第一个参数设置队列 优先级，这样可以控制任务开始执行的先后顺序，第二个参数没有用到</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_HIGH 2 高优先级</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_DEFAULT 0 默认</div><div class="line">#define DISPATCH_QUEUE_PRIORITY_LOW (-2) 低优先级</div><div class="line">*/</div><div class="line">dispatch_get_global_queue(long identifier, unsigned long flags)</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1616138-64a8bc96617a23b5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="GCD_global优先级.png"><br>这样可以根据自己的需要控制任务开始执行的先后顺序。但是如果想让任务结束的时间也按照我们的意愿进行，那就需要使用到串行队列，我们可以根据需要自定义串行队列或者并行队列<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">/*</div><div class="line">自定义队列 queue</div><div class="line">参数一：队列标识符</div><div class="line">参数二：定义队列是串行还是并行，NULL（默认）或者 DISPATCH_QUEUE_SERIAL 为串行，DISPATCH_QUEUE_CONCURRENT 表示并行队列</div><div class="line">*/</div><div class="line">dispatch_queue_create(&lt;#const char * _Nullable label#&gt;, &lt;#dispatch_queue_attr_t  _Nullable attr#&gt;)</div></pre></td></tr></table></figure></p>
<p><img src="http://upload-images.jianshu.io/upload_images/1616138-04c3868a4f55bfee.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自定义串行队列.png"><br><img src="http://upload-images.jianshu.io/upload_images/1616138-cb981897d5c2a4ab.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自定义并行队列.png">由上面的这列张图所示的输出信息可以清楚的看出自定义串行队列和并行队列的区别。<br><br><a name="(2)">（2）dispatch_group的探索：</a><br><br>队列组就是可以对多个队列进行操作的一个组，在队列组中可以对不同队列进行操作监听结果等等，首先来说一下队列组的监听方法<code>dispatch_group_notify</code>的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line">NSLog(@&quot;执行GCD&quot;);</div><div class="line">dispatch_queue_t queue = dispatch_queue_create(&quot;GCD_Group&quot;, DISPATCH_QUEUE_CONCURRENT);</div><div class="line">dispatch_group_t group = dispatch_group_create();</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">NSLog(@&quot;start task 1&quot;);</div><div class="line">[NSThread sleepForTimeInterval:2];</div><div class="line">NSLog(@&quot;end task 1&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">NSLog(@&quot;start task 2&quot;);</div><div class="line">[NSThread sleepForTimeInterval:2];</div><div class="line">NSLog(@&quot;end task 2&quot;);</div><div class="line">&#125;);</div><div class="line">dispatch_group_async(group, queue, ^&#123;</div><div class="line">NSLog(@&quot;start task 3&quot;);</div><div class="line">[NSThread sleepForTimeInterval:2];</div><div class="line">NSLog(@&quot;end task 3&quot;);</div><div class="line">&#125;);</div><div class="line">/// group 组的监听通知，所有task结束之后回调</div><div class="line">dispatch_group_notify(group, queue, ^&#123;</div><div class="line">NSLog(@&quot;All tasks over&quot;);</div><div class="line">/*</div><div class="line">并非另外开辟一个新线程，而是在三个任务中的其中一个子线程进行回调，</div><div class="line">所以如果需要进行刷新 UI的话，需要回调到主线程处理</div><div class="line">*/</div><div class="line">dispatch_async(dispatch_get_main_queue(), ^&#123;</div><div class="line">NSLog(@&quot;回调主线程刷新UI&quot;);</div><div class="line">&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>运行结果为：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-2b18b75d540fb08a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="组队咧监听通知.png"><br>由打印结果可以看出，将三个并行队列放入到队列组中时，使用<code>dispatch_group_notify</code>方法可以对队列执行的结果进行监听，而且这个监听回调只有在队列组中的三个异步线程都处理完成时才会执行回调，这在我们实际开发过程中也是一项非常常见的需求！<br>不少童鞋看到这里可能觉得会用<code>dispatch_group_notify</code>队列组了，但是还有一种更常见的情况是需要倍加注意的，具体请见下列demo：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-69c9583dff13324e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特殊情况队列组.png">输出结果为：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-4b20ac4faa6de469.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="特殊情况队列组输出.png">从队列组输出的信息可以看出，这完全不是预期的输出效果，预期效果因为是：当任务1和任务2都执行完之后在回调<code>dispatch_group_notify</code>，现在打印的结果却是：任务1和任务2开始之后，队列组就回调了<code>dispatch_group_notify</code>，顿时感觉自己使用了一个假的<code>dispatch_group</code>队列组……<br>其实这才是实际开发中最常遇到的场景：当我们执行的任务中调起了一个异步的API请求，那么只要这个异步请求开始发送之后，<code>dispatch_group_async</code>就会认为当前任务已经处理完毕，之后这个异步API处理的事情就不在我的监控范围之内啦，所以就造成了这种打印结果的出现。<br>那么面对这种情况，需要如何处理才能正确监听任务执行结果呢？如下处理：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-e8479335f1a0757a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="使用dispatch_group_enter监听.png">打印输出结果：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-6e90b8733729c14a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="dispatch_group_enter监听结果.png">由此可以看出，强大的GCD应对这种情况已经为我们提供了解决方法，使用<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>便可对队列组中的不同异步请求进行监听，最终执行回调<code>dispatch_group_async</code>方法。但是有两点需要注意的是：（1）<code>dispatch_group_enter</code>和<code>dispatch_group_leave</code>的使用必须是成对出现；（2）<code>dispatch_group_leave</code>必须放在任务的最后一句执行<br>当然GCD的队列组的奥秘远不止这些，目前只是列出了常用的集中以及使用场景，如果感兴趣的大神可以继续参考官方API研究！<br><br><a name="(3)">（3）dispatch_once探究：</a><br><br><code>dispatch_once</code>是GCD提供的一种创建单例的API方法，因为在我们的实际开发过程中，单例也是非常常用的一个场景，例如全局的数据、公共对象等等这些都需要通过单例进行处理，而单例顾名思义，就是在工程的整个运行过程中只会创建一次，然后会存在于内存中。例如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">/// 单例的创建</div><div class="line">+(instancetype)instance &#123;</div><div class="line">static dispatch_once_t onceToken;</div><div class="line">static SingleTest * inst = nil;</div><div class="line">dispatch_once(&amp;onceToken, ^&#123;</div><div class="line">NSLog(@&quot;初始化单例对象&quot;);</div><div class="line">inst = [[SingleTest alloc]init];</div><div class="line">&#125;);</div><div class="line">return inst;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>调用方法<br><img src="http://upload-images.jianshu.io/upload_images/1616138-7e27204ff3581440.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="单例输出.png"><br>从输出也可以看出来，只有当第一次点击方法时会创建对象，之后点击方法时将不会在次创建对象，所有打印的对象内存地址都相同，证明是同一个单例对象<br><br><a name="(4)">（4）dispatch_after探究：</a><br><br><img src="http://upload-images.jianshu.io/upload_images/1616138-d17dd7fd8962bc26.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="延迟执行.png">这是GCD中提供的一个延时操作API，使用起来很简单，但是在个方法会存在一个陷阱，当延时操作开始之后将无法取消，所以当在一个界面执行延时操作时，界面消失之后仍然会执行操作，这样就可能造成程序crash，所以使用的时候需要多加注意。以上就是对GCD进行的一个简单了解<br><br><a name="(D)">（D）NSOperation</a><br><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">1、NSOperation简介</div><div class="line">1.1 NSOperation与GCD的区别：</div><div class="line">OC语言中基于 GCD 的面向对象的封装;</div><div class="line">使用起来比 GCD 更加简单;</div><div class="line">提供了一些用 GCD 不好实现的功能;</div><div class="line">苹果推荐使用，使用 NSOperation 程序员不用关心线程的生命周期</div><div class="line">1.2 NSOperation的特点</div><div class="line">NSOperation 是一个抽象类，抽象类不能直接使用,必须使用它的子类</div><div class="line">抽象类的用处是定义子类共有的属性和方法</div><div class="line"></div><div class="line">2、核心概念</div><div class="line">将操作添加到队列，异步执行。相对于GCD创建任务，将任务添加到队列。</div><div class="line">将NSOperation添加到NSOperationQueue就可以实现多线程编程</div><div class="line"></div><div class="line">3、操作步骤</div><div class="line">先将需要执行的操作封装到一个NSOperation对象中</div><div class="line">然后将NSOperation对象添加到NSOperationQueue中</div><div class="line">系统会自动将NSOperationQueue中的NSOperation取出来</div><div class="line">将取出的NSOperation封装的操作放到一条新线程中执行</div></pre></td></tr></table></figure></p>
<p><br><a name="(D1)">（1）NSInvocationOperation探究</a><br><br><img src="http://upload-images.jianshu.io/upload_images/1616138-efee82091d362196.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSInvocationOperation.png"><br>1、从打印输出的线程 ID可以看出：NSInvocationOperation的输出操作和<code>[invocationOper start]</code>是在同一个线程中，即<code>[invocationOper start]</code>如果在主线程中发起，则NSInvocationOperation的输出操作也在主线程；<code>[invocationOper start]</code>如果在子线程中发起，则NSInvocationOperation的输出操作也在相应的子线程中；NSInvocationOperation不会开启一个新线程<br>2、有打印输出的顺序可以看出：NSInvocationOperation的执行是同步执行的<br><br><a name="(D2)">（2）NSBlockOperation探究</a><br><br><img src="http://upload-images.jianshu.io/upload_images/1616138-b20885c322559948.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSBlockOperation.png">可以发现<code>NSBlockOperation</code>打印的结果和上面<code>NSInvocationOperation</code>如出一辙，一毛一样，这也就证明了系统提供的两个子类<code>NSInvocationOperation ``NSBlockOperation</code>都是同步执行的<br><br><a name="(D3)">（3）NSOperationQueue探究</a><br><br>首先来看一下其相关的概念及关键词<br><img src="http://upload-images.jianshu.io/upload_images/1616138-3658d7864264bb06.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="概念.png"><br><img src="http://upload-images.jianshu.io/upload_images/1616138-45523b8c72695499.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSOperationQueue.png">用输出效果可以看出：<br>在使用<code>NSOperationQueue</code>对象<code>addOperation</code>的方式执行任务，而不是通过 <code>start</code>执行,输出打印的结果会有明显的不同<br>1、<code>NSOperationQueue</code>执行任务会开启一个新线程<br>2、<code>NSOperationQueue</code>执行任务是一个异步的操作过程<br><br><a name="(D4)">（4）自定义NSOperation子类探究 </a><br><br>首先我们可以创建一个<code>NSOperation</code>的子类，并且重写<code>main</code>方法，在代码中是一个什么效果呢？<br><img src="http://upload-images.jianshu.io/upload_images/1616138-4cc35dcc23d2f465.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自定义NSOperation子类.png"><br><img src="http://upload-images.jianshu.io/upload_images/1616138-0216ff01cbe9b8d7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="调用与输出结果.png">从结果看出执行任务依然是开启了一个新线程，而且也是异步执行的过程。<br><br><a name="(D4.1)">（4.1）maxConcurrentOperationCount 属性： </a><br><br>未设置并发数时，默认所有任务同时并发执行<img src="http://upload-images.jianshu.io/upload_images/1616138-afb3677a6386f800.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="未设置并发数.png"><br>当设置了最大并发数为 2 时，如下图可以看出<code>NSOperationQueue</code>同时执行的任务数也为两个，当前两个任务执行完毕之后才继续执行后面的任务<br><img src="http://upload-images.jianshu.io/upload_images/1616138-c20c26b8c4a08bd2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="最大并发数.png"><br><br><a name="(D4.2)">（4.2）addDependency 方法添加依赖： </a><br><br>一般在我们的实际开发过程中，会遇到异步任务一需要等待异步任务二完成之后才能执行，这种情况下可以就会想到使用多线程的依赖进行实现（当然使用上面说的GCD也可以），那下面就说一下 <code>NSOperation</code>中的<code>addDependency</code>方法：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-d0152bc192d0f36f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="addDependency.png">首先要看一下Demo中的依赖关系是如何添加的？<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">[customA addDependency:customC];</div><div class="line">[customC addDependency:customB];</div><div class="line">[customB addDependency:customD];</div></pre></td></tr></table></figure></p>
<p>这三句表示的依赖关系是：<code>customA -&gt; customC -&gt; customB -&gt; customD``customA任务</code>需要在<code>customC任务</code>执行之后才能执行；<code>customC任务</code>需要在<code>customB任务</code>执行之后才能执行；<code>customB任务</code>需要在<code>customD任务</code>执行之后才能执行【注意：<code>customD任务</code>不能再依赖于<code>customA任务</code>,否则就会造成死锁】；使用看到了最终控制台输出的顺序效果。</p>
<p>当然上面这是一种理想的状态，如果出现了下面这种 “ 变态 ” 情况，这种依赖关系还可靠吗？？？<br>当自定NSOperation的自定义类中的<code>main</code>方法执行的是一个异步任务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">-(void)main&#123;  </div><div class="line">dispatch_async(dispatch_get_global_queue(0, 0), ^&#123;</div><div class="line">[NSThread sleepForTimeInterval:1];</div><div class="line">if (self.cancelled) &#123;</div><div class="line">return ;</div><div class="line">&#125;</div><div class="line">NSLog(@&quot;---%@&quot;,self.operName);</div><div class="line">&#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>输出的打印顺序如下：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-163cdde0b85f12b6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="依赖异常.png">这明显不是按照依赖顺序输出的！那问题到底出在哪呢？<br>其实是因为自定义的NSOperation子类<code>main</code>方法中，因为<code>main</code>方法执行的是一个异步任务，当任务开始执行之后，NSOperation子类就默认依赖任务完成，而无法监听到这个异步任务执行结束。<br>但是这种场景也是实际开发中经常用到的，所以要怎样处理呢？解决方法就是使用<code>NSRunLoop</code>进行解决：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-a7f979791b7865aa.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSRunLoop进行解决.png"><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">while (!self.over &amp;&amp; !self.cancelled) &#123;</div><div class="line">[[NSRunLoop currentRunLoop]runMode:NSDefaultRunLoopMode beforeDate:[NSDate distantFuture]];</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>在代码中的这句作用就是让当前的 RunLoop 在<code>main方法中</code>等待异步任务的结束，这样一来问题就完美解决啦，下面看一下输出效果：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-30fca34d2871dff3.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="结果.png"><br>输出的结果符合自己设置的依赖预期，问题完美解决。<br><br><a name="(七)">（七）线程锁相关</a><br><br>多线程在开发中给我们带来了很多遍历，但是正如上面所说的多线程也存在一些缺点，例如：<br>统一个资源可能会被多个线程共享，也就是多个线程可能会访问同一块资源，当多个线程访问同一块资源时，很容易引发数据错乱和数据安全问题，那么这里就需要强调一下<code>线程锁</code>的概念:<br>关于线程锁的说明，有一个最经典的例子就是购票系统的例子：下面我也根据这个场景说明一下线程锁的使用及重要性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div><div class="line">56</div></pre></td><td class="code"><pre><div class="line">#import &quot;TicketManager.h&quot;</div><div class="line"></div><div class="line">@interface TicketManager ()</div><div class="line">/**</div><div class="line">剩余票数</div><div class="line">*/</div><div class="line">@property (nonatomic,assign)NSInteger tickets;</div><div class="line">/**</div><div class="line">卖出票数</div><div class="line">*/</div><div class="line">@property (nonatomic,assign)NSInteger saleCount;</div><div class="line">/**</div><div class="line">杭州卖票点（线程模拟）</div><div class="line">*/</div><div class="line">@property (nonatomic,strong)NSThread * thread_HZ;</div><div class="line">/**</div><div class="line">上海买票点（线程模拟）</div><div class="line">*/</div><div class="line">@property (nonatomic,strong)NSThread * thread_SH;</div><div class="line">@end</div><div class="line"></div><div class="line">#define TotalTicket 10// 总票数</div><div class="line"></div><div class="line">@implementation TicketManager</div><div class="line"></div><div class="line">- (instancetype)init&#123;</div><div class="line">if (self = [super init]) &#123;</div><div class="line"></div><div class="line">self.tickets = TotalTicket;</div><div class="line">self.thread_HZ = [[NSThread alloc]initWithTarget:self selector:@selector(sale) object:nil];</div><div class="line">[self.thread_HZ setName:@&quot;HZ_Thread&quot;];</div><div class="line">self.thread_SH = [[NSThread alloc]initWithTarget:self selector:@selector(sale) object:nil];</div><div class="line">[self.thread_SH setName:@&quot;SH_Thread&quot;];</div><div class="line">&#125;</div><div class="line">return  self;</div><div class="line">&#125;</div><div class="line">/// 访问同一份资源，票库</div><div class="line">-(void)sale &#123;</div><div class="line"></div><div class="line">while (true) &#123;</div><div class="line">if (self.tickets &gt; 0) &#123;</div><div class="line">[NSThread sleepForTimeInterval:0.5];</div><div class="line">self.tickets -- ;</div><div class="line">self.saleCount = TotalTicket - self.tickets;</div><div class="line"></div><div class="line">NSLog(@&quot;站点：%@， 当前余票：%ld，售出：%ld&quot;,[NSThread currentThread].name,(long)self.tickets,(long)self.saleCount);</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">&#125;</div><div class="line">/// 开始卖票</div><div class="line">-(void)startToSaleTicket&#123;</div><div class="line">[self.thread_HZ start];</div><div class="line">[self.thread_SH start];</div><div class="line">&#125;</div><div class="line"></div><div class="line">@end</div></pre></td></tr></table></figure></p>
<p>这种是一个没有线程锁的情况，那先看一下打印的输出结果：<br><img src="http://upload-images.jianshu.io/upload_images/1616138-aa7c124a29a22ac9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="售票.png">从结果可以明显的看出多线程访问统一资源的问题，会出现数据错乱。接下来就看一下几种线程锁：<br>1、互斥锁@synchronized (self) 【使用简单，但是小号CPU资源较大】<br><img src="http://upload-images.jianshu.io/upload_images/1616138-ee0ca6dda1a58f2e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="互斥锁.png"><br>2、NSCondition加锁<br><img src="http://upload-images.jianshu.io/upload_images/1616138-85bfa8f0d76a2b5f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSCondition加锁.png"><br>3、NSLock加锁<br><img src="http://upload-images.jianshu.io/upload_images/1616138-3549879e1f98518f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="NSLock加锁.png"><br>从三种加锁方式的输出结果可以看出，都能达到预期，能有效防止因多线程抢夺资源造成的数据安全问题。至于具体使用哪种方式，可以根据自己的需求进行选择。<br><br><a name="(八)">（八）总结</a><br><br>本文只是对多线程进行了一个简单的探索研究，希望能够帮助到有需要的童鞋，文章提到的一些知识点并不是很深，需要进行深入研究的朋友可以直接翻看官方API，如果文章中有不足的地方，欢迎指正！</p>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-03-08</span><i class="fa fa-comment-o"></i><a href="/2017/03/08/iOS-Thread/#comments">评论</a><i class="fa fa-tag"></i></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div></div><div class="pagination"><ul class="clearfix"><li class="next pagbuttons"><a role="navigation" href="/2017/03/07/hello-world/" title="Hello World" class="btn">下一篇</a></li></ul></div><a id="comments"></a><div id="disqus_thread"></div><script>var disqus_shortname = 'seansun';
var disqus_identifier = '2017/03/08/iOS-Thread/';
var disqus_title = '浅谈iOS中多线程开发';
var disqus_url = 'https://Kinglions.github.io/2017/03/08/iOS-Thread/';
(function() {
    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
    dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
})();</script><script id="dsq-count-scr" src="//seansun.disqus.com/count.js" async></script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>